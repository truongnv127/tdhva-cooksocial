{"ast":null,"code":"import _objectSpread from \"/home/truongnvops/Documents/Project_AWS/tdhva-cooksocial/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ConsoleLogger, createGetCredentialsForIdentityClient } from '@aws-amplify/core';\nimport { assertIdentityPoolIdConfig } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError.mjs';\nimport { getRegionFromIdentityPoolId } from '../../../foundation/parsers/regionParsers.mjs';\nimport { assertIdTokenInAuthTokens } from '../utils/types.mjs';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport { createCognitoIdentityPoolEndpointResolver } from '../factories/createCognitoIdentityPoolEndpointResolver.mjs';\nimport { cognitoIdentityIdProvider } from './IdentityIdProvider.mjs';\nimport { formLoginsMap } from './utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('CognitoCredentialsProvider');\nconst CREDENTIALS_TTL = 50 * 60 * 1000; // 50 min, can be modified on config if required in the future\nclass CognitoAWSCredentialsAndIdentityIdProvider {\n  constructor(identityIdStore) {\n    this._nextCredentialsRefresh = 0;\n    this._identityIdStore = identityIdStore;\n  }\n  async clearCredentialsAndIdentityId() {\n    logger.debug('Clearing out credentials and identityId');\n    this._credentialsAndIdentityId = undefined;\n    await this._identityIdStore.clearIdentityId();\n  }\n  async clearCredentials() {\n    logger.debug('Clearing out in-memory credentials');\n    this._credentialsAndIdentityId = undefined;\n  }\n  async getCredentialsAndIdentityId(getCredentialsOptions) {\n    const isAuthenticated = getCredentialsOptions.authenticated;\n    const {\n      tokens\n    } = getCredentialsOptions;\n    const {\n      authConfig\n    } = getCredentialsOptions;\n    try {\n      assertIdentityPoolIdConfig(authConfig === null || authConfig === void 0 ? void 0 : authConfig.Cognito);\n    } catch (_unused) {\n      // No identity pool configured, skipping\n      return;\n    }\n    if (!isAuthenticated && !authConfig.Cognito.allowGuestAccess) {\n      // TODO(V6): return partial result like Native platforms\n      return;\n    }\n    const {\n      forceRefresh\n    } = getCredentialsOptions;\n    const tokenHasChanged = this.hasTokenChanged(tokens);\n    const identityId = await cognitoIdentityIdProvider({\n      tokens,\n      authConfig: authConfig.Cognito,\n      identityIdStore: this._identityIdStore\n    });\n    // Clear cached credentials when forceRefresh is true OR the cache token has changed\n    if (forceRefresh || tokenHasChanged) {\n      this.clearCredentials();\n    }\n    if (!isAuthenticated) {\n      return this.getGuestCredentials(identityId, authConfig.Cognito);\n    } else {\n      assertIdTokenInAuthTokens(tokens);\n      return this.credsForOIDCTokens(authConfig.Cognito, tokens, identityId);\n    }\n  }\n  async getGuestCredentials(identityId, authConfig) {\n    var _clientResult, _clientResult2;\n    // Return existing in-memory cached credentials only if it exists, is not past it's lifetime and is unauthenticated credentials\n    if (this._credentialsAndIdentityId && !this.isPastTTL() && this._credentialsAndIdentityId.isAuthenticatedCreds === false) {\n      logger.info('returning stored credentials as they neither past TTL nor expired.');\n      return this._credentialsAndIdentityId;\n    }\n    // Clear to discard if any authenticated credentials are set and start with a clean slate\n    this.clearCredentials();\n    const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n    const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n      endpointResolver: createCognitoIdentityPoolEndpointResolver({\n        endpointOverride: authConfig.identityPoolEndpoint\n      })\n    });\n    // use identityId to obtain guest credentials\n    // save credentials in-memory\n    // No logins params should be passed for guest creds:\n    // https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html\n    let clientResult;\n    try {\n      clientResult = await getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId\n      });\n    } catch (e) {\n      assertServiceError(e);\n      throw new AuthError(e);\n    }\n    if ((_clientResult = clientResult) !== null && _clientResult !== void 0 && (_clientResult = _clientResult.Credentials) !== null && _clientResult !== void 0 && _clientResult.AccessKeyId && (_clientResult2 = clientResult) !== null && _clientResult2 !== void 0 && (_clientResult2 = _clientResult2.Credentials) !== null && _clientResult2 !== void 0 && _clientResult2.SecretKey) {\n      this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n      const res = {\n        credentials: {\n          accessKeyId: clientResult.Credentials.AccessKeyId,\n          secretAccessKey: clientResult.Credentials.SecretKey,\n          sessionToken: clientResult.Credentials.SessionToken,\n          expiration: clientResult.Credentials.Expiration\n        },\n        identityId\n      };\n      if (clientResult.IdentityId) {\n        res.identityId = clientResult.IdentityId;\n        this._identityIdStore.storeIdentityId({\n          id: clientResult.IdentityId,\n          type: 'guest'\n        });\n      }\n      this._credentialsAndIdentityId = _objectSpread(_objectSpread({}, res), {}, {\n        isAuthenticatedCreds: false\n      });\n      return res;\n    } else {\n      throw new AuthError({\n        name: 'CredentialsNotFoundException',\n        message: \"Cognito did not respond with either Credentials, AccessKeyId or SecretKey.\"\n      });\n    }\n  }\n  async credsForOIDCTokens(authConfig, authTokens, identityId) {\n    var _clientResult3, _clientResult4;\n    if (this._credentialsAndIdentityId && !this.isPastTTL() && this._credentialsAndIdentityId.isAuthenticatedCreds === true) {\n      logger.debug('returning stored credentials as they neither past TTL nor expired.');\n      return this._credentialsAndIdentityId;\n    }\n    // Clear to discard if any unauthenticated credentials are set and start with a clean slate\n    this.clearCredentials();\n    const logins = authTokens.idToken ? formLoginsMap(authTokens.idToken.toString()) : {};\n    const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n    const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n      endpointResolver: createCognitoIdentityPoolEndpointResolver({\n        endpointOverride: authConfig.identityPoolEndpoint\n      })\n    });\n    let clientResult;\n    try {\n      clientResult = await getCredentialsForIdentity({\n        region\n      }, {\n        IdentityId: identityId,\n        Logins: logins\n      });\n    } catch (e) {\n      assertServiceError(e);\n      throw new AuthError(e);\n    }\n    if ((_clientResult3 = clientResult) !== null && _clientResult3 !== void 0 && (_clientResult3 = _clientResult3.Credentials) !== null && _clientResult3 !== void 0 && _clientResult3.AccessKeyId && (_clientResult4 = clientResult) !== null && _clientResult4 !== void 0 && (_clientResult4 = _clientResult4.Credentials) !== null && _clientResult4 !== void 0 && _clientResult4.SecretKey) {\n      var _authTokens$idToken;\n      this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n      const res = {\n        credentials: {\n          accessKeyId: clientResult.Credentials.AccessKeyId,\n          secretAccessKey: clientResult.Credentials.SecretKey,\n          sessionToken: clientResult.Credentials.SessionToken,\n          expiration: clientResult.Credentials.Expiration\n        },\n        identityId\n      };\n      if (clientResult.IdentityId) {\n        res.identityId = clientResult.IdentityId;\n        // note: the following call removes guest identityId from the persistent store (localStorage)\n        this._identityIdStore.storeIdentityId({\n          id: clientResult.IdentityId,\n          type: 'primary'\n        });\n      }\n      // Store the credentials in-memory along with the expiration\n      this._credentialsAndIdentityId = _objectSpread(_objectSpread({}, res), {}, {\n        isAuthenticatedCreds: true,\n        associatedIdToken: (_authTokens$idToken = authTokens.idToken) === null || _authTokens$idToken === void 0 ? void 0 : _authTokens$idToken.toString()\n      });\n      return res;\n    } else {\n      throw new AuthError({\n        name: 'CredentialsException',\n        message: \"Cognito did not respond with either Credentials, AccessKeyId or SecretKey.\"\n      });\n    }\n  }\n  isPastTTL() {\n    return this._nextCredentialsRefresh === undefined ? true : this._nextCredentialsRefresh <= Date.now();\n  }\n  hasTokenChanged(tokens) {\n    var _this$_credentialsAnd, _tokens$idToken;\n    return !!tokens && !!((_this$_credentialsAnd = this._credentialsAndIdentityId) !== null && _this$_credentialsAnd !== void 0 && _this$_credentialsAnd.associatedIdToken) && ((_tokens$idToken = tokens.idToken) === null || _tokens$idToken === void 0 ? void 0 : _tokens$idToken.toString()) !== this._credentialsAndIdentityId.associatedIdToken;\n  }\n}\nexport { CognitoAWSCredentialsAndIdentityIdProvider };","map":{"version":3,"names":["logger","ConsoleLogger","CREDENTIALS_TTL","CognitoAWSCredentialsAndIdentityIdProvider","constructor","identityIdStore","_nextCredentialsRefresh","_identityIdStore","clearCredentialsAndIdentityId","debug","_credentialsAndIdentityId","undefined","clearIdentityId","clearCredentials","getCredentialsAndIdentityId","getCredentialsOptions","isAuthenticated","authenticated","tokens","authConfig","assertIdentityPoolIdConfig","Cognito","_unused","allowGuestAccess","forceRefresh","tokenHasChanged","hasTokenChanged","identityId","cognitoIdentityIdProvider","getGuestCredentials","assertIdTokenInAuthTokens","credsForOIDCTokens","_clientResult","_clientResult2","isPastTTL","isAuthenticatedCreds","info","region","getRegionFromIdentityPoolId","identityPoolId","getCredentialsForIdentity","createGetCredentialsForIdentityClient","endpointResolver","createCognitoIdentityPoolEndpointResolver","endpointOverride","identityPoolEndpoint","clientResult","IdentityId","e","assertServiceError","AuthError","Credentials","AccessKeyId","SecretKey","Date","getTime","res","credentials","accessKeyId","secretAccessKey","sessionToken","SessionToken","expiration","Expiration","storeIdentityId","id","type","_objectSpread","name","message","authTokens","_clientResult3","_clientResult4","logins","idToken","formLoginsMap","toString","Logins","_authTokens$idToken","associatedIdToken","now","_this$_credentialsAnd","_tokens$idToken"],"sources":["/home/truongnvops/Documents/Project_AWS/tdhva-cooksocial/frontend/node_modules/@aws-amplify/auth/src/providers/cognito/credentialsProvider/credentialsProvider.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger, createGetCredentialsForIdentityClient, } from '@aws-amplify/core';\nimport { assertIdentityPoolIdConfig, } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError';\nimport { getRegionFromIdentityPoolId } from '../../../foundation/parsers';\nimport { assertIdTokenInAuthTokens } from '../utils/types';\nimport { createCognitoIdentityPoolEndpointResolver } from '../factories';\nimport { cognitoIdentityIdProvider } from './IdentityIdProvider';\nimport { formLoginsMap } from './utils';\nconst logger = new ConsoleLogger('CognitoCredentialsProvider');\nconst CREDENTIALS_TTL = 50 * 60 * 1000; // 50 min, can be modified on config if required in the future\nexport class CognitoAWSCredentialsAndIdentityIdProvider {\n    constructor(identityIdStore) {\n        this._nextCredentialsRefresh = 0;\n        this._identityIdStore = identityIdStore;\n    }\n    async clearCredentialsAndIdentityId() {\n        logger.debug('Clearing out credentials and identityId');\n        this._credentialsAndIdentityId = undefined;\n        await this._identityIdStore.clearIdentityId();\n    }\n    async clearCredentials() {\n        logger.debug('Clearing out in-memory credentials');\n        this._credentialsAndIdentityId = undefined;\n    }\n    async getCredentialsAndIdentityId(getCredentialsOptions) {\n        const isAuthenticated = getCredentialsOptions.authenticated;\n        const { tokens } = getCredentialsOptions;\n        const { authConfig } = getCredentialsOptions;\n        try {\n            assertIdentityPoolIdConfig(authConfig?.Cognito);\n        }\n        catch {\n            // No identity pool configured, skipping\n            return;\n        }\n        if (!isAuthenticated && !authConfig.Cognito.allowGuestAccess) {\n            // TODO(V6): return partial result like Native platforms\n            return;\n        }\n        const { forceRefresh } = getCredentialsOptions;\n        const tokenHasChanged = this.hasTokenChanged(tokens);\n        const identityId = await cognitoIdentityIdProvider({\n            tokens,\n            authConfig: authConfig.Cognito,\n            identityIdStore: this._identityIdStore,\n        });\n        // Clear cached credentials when forceRefresh is true OR the cache token has changed\n        if (forceRefresh || tokenHasChanged) {\n            this.clearCredentials();\n        }\n        if (!isAuthenticated) {\n            return this.getGuestCredentials(identityId, authConfig.Cognito);\n        }\n        else {\n            assertIdTokenInAuthTokens(tokens);\n            return this.credsForOIDCTokens(authConfig.Cognito, tokens, identityId);\n        }\n    }\n    async getGuestCredentials(identityId, authConfig) {\n        // Return existing in-memory cached credentials only if it exists, is not past it's lifetime and is unauthenticated credentials\n        if (this._credentialsAndIdentityId &&\n            !this.isPastTTL() &&\n            this._credentialsAndIdentityId.isAuthenticatedCreds === false) {\n            logger.info('returning stored credentials as they neither past TTL nor expired.');\n            return this._credentialsAndIdentityId;\n        }\n        // Clear to discard if any authenticated credentials are set and start with a clean slate\n        this.clearCredentials();\n        const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n        const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n            endpointResolver: createCognitoIdentityPoolEndpointResolver({\n                endpointOverride: authConfig.identityPoolEndpoint,\n            }),\n        });\n        // use identityId to obtain guest credentials\n        // save credentials in-memory\n        // No logins params should be passed for guest creds:\n        // https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html\n        let clientResult;\n        try {\n            clientResult = await getCredentialsForIdentity({ region }, {\n                IdentityId: identityId,\n            });\n        }\n        catch (e) {\n            assertServiceError(e);\n            throw new AuthError(e);\n        }\n        if (clientResult?.Credentials?.AccessKeyId &&\n            clientResult?.Credentials?.SecretKey) {\n            this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n            const res = {\n                credentials: {\n                    accessKeyId: clientResult.Credentials.AccessKeyId,\n                    secretAccessKey: clientResult.Credentials.SecretKey,\n                    sessionToken: clientResult.Credentials.SessionToken,\n                    expiration: clientResult.Credentials.Expiration,\n                },\n                identityId,\n            };\n            if (clientResult.IdentityId) {\n                res.identityId = clientResult.IdentityId;\n                this._identityIdStore.storeIdentityId({\n                    id: clientResult.IdentityId,\n                    type: 'guest',\n                });\n            }\n            this._credentialsAndIdentityId = {\n                ...res,\n                isAuthenticatedCreds: false,\n            };\n            return res;\n        }\n        else {\n            throw new AuthError({\n                name: 'CredentialsNotFoundException',\n                message: `Cognito did not respond with either Credentials, AccessKeyId or SecretKey.`,\n            });\n        }\n    }\n    async credsForOIDCTokens(authConfig, authTokens, identityId) {\n        if (this._credentialsAndIdentityId &&\n            !this.isPastTTL() &&\n            this._credentialsAndIdentityId.isAuthenticatedCreds === true) {\n            logger.debug('returning stored credentials as they neither past TTL nor expired.');\n            return this._credentialsAndIdentityId;\n        }\n        // Clear to discard if any unauthenticated credentials are set and start with a clean slate\n        this.clearCredentials();\n        const logins = authTokens.idToken\n            ? formLoginsMap(authTokens.idToken.toString())\n            : {};\n        const region = getRegionFromIdentityPoolId(authConfig.identityPoolId);\n        const getCredentialsForIdentity = createGetCredentialsForIdentityClient({\n            endpointResolver: createCognitoIdentityPoolEndpointResolver({\n                endpointOverride: authConfig.identityPoolEndpoint,\n            }),\n        });\n        let clientResult;\n        try {\n            clientResult = await getCredentialsForIdentity({ region }, {\n                IdentityId: identityId,\n                Logins: logins,\n            });\n        }\n        catch (e) {\n            assertServiceError(e);\n            throw new AuthError(e);\n        }\n        if (clientResult?.Credentials?.AccessKeyId &&\n            clientResult?.Credentials?.SecretKey) {\n            this._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;\n            const res = {\n                credentials: {\n                    accessKeyId: clientResult.Credentials.AccessKeyId,\n                    secretAccessKey: clientResult.Credentials.SecretKey,\n                    sessionToken: clientResult.Credentials.SessionToken,\n                    expiration: clientResult.Credentials.Expiration,\n                },\n                identityId,\n            };\n            if (clientResult.IdentityId) {\n                res.identityId = clientResult.IdentityId;\n                // note: the following call removes guest identityId from the persistent store (localStorage)\n                this._identityIdStore.storeIdentityId({\n                    id: clientResult.IdentityId,\n                    type: 'primary',\n                });\n            }\n            // Store the credentials in-memory along with the expiration\n            this._credentialsAndIdentityId = {\n                ...res,\n                isAuthenticatedCreds: true,\n                associatedIdToken: authTokens.idToken?.toString(),\n            };\n            return res;\n        }\n        else {\n            throw new AuthError({\n                name: 'CredentialsException',\n                message: `Cognito did not respond with either Credentials, AccessKeyId or SecretKey.`,\n            });\n        }\n    }\n    isPastTTL() {\n        return this._nextCredentialsRefresh === undefined\n            ? true\n            : this._nextCredentialsRefresh <= Date.now();\n    }\n    hasTokenChanged(tokens) {\n        return (!!tokens &&\n            !!this._credentialsAndIdentityId?.associatedIdToken &&\n            tokens.idToken?.toString() !==\n                this._credentialsAndIdentityId.associatedIdToken);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}