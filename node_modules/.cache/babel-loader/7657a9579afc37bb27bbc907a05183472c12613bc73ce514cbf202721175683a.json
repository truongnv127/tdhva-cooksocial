{"ast":null,"code":"import _objectSpread from \"/home/truongnvops/Documents/Project_AWS/tdhva-cooksocial/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Amplify } from '@aws-amplify/core';\nimport { AuthAction, assertTokenProviderConfig, AmplifyUrl } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { InitiateAuthException } from '../types/errors.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { AuthValidationErrorCode } from '../../../errors/types/validation.mjs';\nimport { assertValidationError } from '../../../errors/utils/assertValidationError.mjs';\nimport { USER_ALREADY_AUTHENTICATED_EXCEPTION } from '../../../errors/constants.mjs';\nimport { getCurrentUser } from '../apis/getCurrentUser.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { createInitiateAuthClient } from '../../../foundation/factories/serviceClients/cognitoIdentityProvider/createInitiateAuthClient.mjs';\nimport '@aws-amplify/core/internals/aws-client-utils/composers';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport '../../../foundation/factories/serviceClients/cognitoIdentityProvider/shared/handler/cognitoUserPoolTransferHandler.mjs';\nimport '../../../foundation/factories/serviceClients/cognitoIdentityProvider/constants.mjs';\nimport { createRespondToAuthChallengeClient } from '../../../foundation/factories/serviceClients/cognitoIdentityProvider/createRespondToAuthChallengeClient.mjs';\nimport { createVerifySoftwareTokenClient } from '../../../foundation/factories/serviceClients/cognitoIdentityProvider/createVerifySoftwareTokenClient.mjs';\nimport { createAssociateSoftwareTokenClient } from '../../../foundation/factories/serviceClients/cognitoIdentityProvider/createAssociateSoftwareTokenClient.mjs';\nimport { createCognitoUserPoolEndpointResolver } from '../factories/createCognitoUserPoolEndpointResolver.mjs';\nimport { getRegionFromUserPoolId } from '../../../foundation/parsers/regionParsers.mjs';\nimport { handleWebAuthnSignInResult } from '../../../client/flows/userAuth/handleWebAuthnSignInResult.mjs';\nimport { handlePasswordSRP } from '../../../client/flows/shared/handlePasswordSRP.mjs';\nimport { initiateSelectedChallenge } from '../../../client/flows/userAuth/handleSelectChallenge.mjs';\nimport { handleSelectChallengeWithPassword } from '../../../client/flows/userAuth/handleSelectChallengeWithPassword.mjs';\nimport { handleSelectChallengeWithPasswordSRP } from '../../../client/flows/userAuth/handleSelectChallengeWithPasswordSRP.mjs';\nimport '../../../client/utils/store/autoSignInStore.mjs';\nimport { signInStore } from '../../../client/utils/store/signInStore.mjs';\nimport { getAuthenticationHelper } from './srp/getAuthenticationHelper.mjs';\nimport './srp/constants.mjs';\nimport '@aws-crypto/sha256-js';\nimport { getUserContextData } from './userContextData.mjs';\nimport { handlePasswordVerifierChallenge } from './handlePasswordVerifierChallenge.mjs';\nimport { handleDeviceSRPAuth } from './handleDeviceSRPAuth.mjs';\nimport { retryOnResourceNotFoundException } from './retryOnResourceNotFoundException.mjs';\nimport { setActiveSignInUsername } from './setActiveSignInUsername.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst USER_ATTRIBUTES = 'userAttributes.';\nfunction isWebAuthnResultAuthSignInOutput(result) {\n  return 'isSignedIn' in result && 'nextStep' in result;\n}\nasync function handleCustomChallenge(_ref) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config,\n    tokenOrchestrator\n  } = _ref;\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  const challengeResponses = {\n    USERNAME: username,\n    ANSWER: challengeResponse\n  };\n  const deviceMetadata = await (tokenOrchestrator === null || tokenOrchestrator === void 0 ? void 0 : tokenOrchestrator.getDeviceMetadata(username));\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'CUSTOM_CHALLENGE',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const respondToAuthChallenge = createRespondToAuthChallengeClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  const response = await respondToAuthChallenge({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') {\n    return handleDeviceSRPAuth({\n      username,\n      config,\n      clientMetadata,\n      session: response.Session,\n      tokenOrchestrator\n    });\n  }\n  return response;\n}\nasync function handleMFASetupChallenge(_ref2) {\n  let {\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    deviceName,\n    config\n  } = _ref2;\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  if (challengeResponse === 'EMAIL') {\n    return {\n      ChallengeName: 'MFA_SETUP',\n      Session: session,\n      ChallengeParameters: {\n        MFAS_CAN_SETUP: '[\"EMAIL_OTP\"]'\n      },\n      $metadata: {}\n    };\n  }\n  if (challengeResponse === 'TOTP') {\n    return {\n      ChallengeName: 'MFA_SETUP',\n      Session: session,\n      ChallengeParameters: {\n        MFAS_CAN_SETUP: '[\"SOFTWARE_TOKEN_MFA\"]'\n      },\n      $metadata: {}\n    };\n  }\n  const challengeResponses = {\n    USERNAME: username\n  };\n  const isTOTPCode = /^\\d+$/.test(challengeResponse);\n  if (isTOTPCode) {\n    const verifySoftwareToken = createVerifySoftwareTokenClient({\n      endpointResolver: createCognitoUserPoolEndpointResolver({\n        endpointOverride: userPoolEndpoint\n      })\n    });\n    const {\n      Session\n    } = await verifySoftwareToken({\n      region: getRegionFromUserPoolId(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, {\n      UserCode: challengeResponse,\n      Session: session,\n      FriendlyDeviceName: deviceName\n    });\n    signInStore.dispatch({\n      type: 'SET_SIGN_IN_SESSION',\n      value: Session\n    });\n    const jsonReq = {\n      ChallengeName: 'MFA_SETUP',\n      ChallengeResponses: challengeResponses,\n      Session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n      endpointResolver: createCognitoUserPoolEndpointResolver({\n        endpointOverride: userPoolEndpoint\n      })\n    });\n    return respondToAuthChallenge({\n      region: getRegionFromUserPoolId(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  }\n  const isEmail = challengeResponse.includes('@');\n  if (isEmail) {\n    challengeResponses.EMAIL = challengeResponse;\n    const jsonReq = {\n      ChallengeName: 'MFA_SETUP',\n      ChallengeResponses: challengeResponses,\n      Session: session,\n      ClientMetadata: clientMetadata,\n      ClientId: userPoolClientId\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n      endpointResolver: createCognitoUserPoolEndpointResolver({\n        endpointOverride: userPoolEndpoint\n      })\n    });\n    return respondToAuthChallenge({\n      region: getRegionFromUserPoolId(userPoolId),\n      userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n    }, jsonReq);\n  }\n  throw new AuthError({\n    name: AuthErrorCodes.SignInException,\n    message: \"Cannot proceed with MFA setup using challengeResponse: \".concat(challengeResponse),\n    recoverySuggestion: 'Try passing \"EMAIL\", \"TOTP\", a valid email, or OTP code as the challengeResponse.'\n  });\n}\nasync function handleSelectMFATypeChallenge(_ref3) {\n  let {\n    challengeResponse,\n    username,\n    clientMetadata,\n    session,\n    config\n  } = _ref3;\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  assertValidationError(challengeResponse === 'TOTP' || challengeResponse === 'SMS' || challengeResponse === 'EMAIL', AuthValidationErrorCode.IncorrectMFAMethod);\n  const challengeResponses = {\n    USERNAME: username,\n    ANSWER: mapMfaType(challengeResponse)\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'SELECT_MFA_TYPE',\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const respondToAuthChallenge = createRespondToAuthChallengeClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  return respondToAuthChallenge({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleCompleteNewPasswordChallenge(_ref4) {\n  let {\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    requiredAttributes,\n    config\n  } = _ref4;\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  const challengeResponses = _objectSpread(_objectSpread({}, createAttributes(requiredAttributes)), {}, {\n    NEW_PASSWORD: challengeResponse,\n    USERNAME: username\n  });\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: 'NEW_PASSWORD_REQUIRED',\n    ChallengeResponses: challengeResponses,\n    ClientMetadata: clientMetadata,\n    Session: session,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const respondToAuthChallenge = createRespondToAuthChallengeClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  return respondToAuthChallenge({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nasync function handleUserPasswordAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  var _ref5, _response$ChallengePa, _response$ChallengePa2, _response$ChallengePa3;\n  const {\n    userPoolClientId,\n    userPoolId,\n    userPoolEndpoint\n  } = config;\n  const authParameters = {\n    USERNAME: username,\n    PASSWORD: password\n  };\n  const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'USER_PASSWORD_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const initiateAuth = createInitiateAuthClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  const response = await initiateAuth({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_ref5 = (_response$ChallengePa = (_response$ChallengePa2 = response.ChallengeParameters) === null || _response$ChallengePa2 === void 0 ? void 0 : _response$ChallengePa2.USERNAME) !== null && _response$ChallengePa !== void 0 ? _response$ChallengePa : (_response$ChallengePa3 = response.ChallengeParameters) === null || _response$ChallengePa3 === void 0 ? void 0 : _response$ChallengePa3.USER_ID_FOR_SRP) !== null && _ref5 !== void 0 ? _ref5 : username;\n  setActiveSignInUsername(activeUsername);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n    username: activeUsername,\n    config,\n    clientMetadata,\n    session: response.Session,\n    tokenOrchestrator\n  });\n  return response;\n}\nasync function handleUserSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  return handlePasswordSRP({\n    username,\n    password,\n    clientMetadata,\n    config,\n    tokenOrchestrator,\n    authFlow: 'USER_SRP_AUTH'\n  });\n}\nasync function handleCustomAuthFlowWithoutSRP(username, clientMetadata, config, tokenOrchestrator) {\n  var _response$ChallengePa4, _response$ChallengePa5;\n  const {\n    userPoolClientId,\n    userPoolId,\n    userPoolEndpoint\n  } = config;\n  const authParameters = {\n    USERNAME: username\n  };\n  const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n  if (deviceMetadata && deviceMetadata.deviceKey) {\n    authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n  }\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'CUSTOM_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const initiateAuth = createInitiateAuthClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  const response = await initiateAuth({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_response$ChallengePa4 = (_response$ChallengePa5 = response.ChallengeParameters) === null || _response$ChallengePa5 === void 0 ? void 0 : _response$ChallengePa5.USERNAME) !== null && _response$ChallengePa4 !== void 0 ? _response$ChallengePa4 : username;\n  setActiveSignInUsername(activeUsername);\n  if (response.ChallengeName === 'DEVICE_SRP_AUTH') return handleDeviceSRPAuth({\n    username: activeUsername,\n    config,\n    clientMetadata,\n    session: response.Session,\n    tokenOrchestrator\n  });\n  return response;\n}\nasync function handleCustomSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n  var _challengeParameters$;\n  assertTokenProviderConfig(config);\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  const userPoolName = (userPoolId === null || userPoolId === void 0 ? void 0 : userPoolId.split('_')[1]) || '';\n  const authenticationHelper = await getAuthenticationHelper(userPoolName);\n  const authParameters = {\n    USERNAME: username,\n    SRP_A: authenticationHelper.A.toString(16),\n    CHALLENGE_NAME: 'SRP_A'\n  };\n  const UserContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    AuthFlow: 'CUSTOM_AUTH',\n    AuthParameters: authParameters,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData\n  };\n  const initiateAuth = createInitiateAuthClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  const {\n    ChallengeParameters: challengeParameters,\n    Session: session\n  } = await initiateAuth({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.SignIn)\n  }, jsonReq);\n  const activeUsername = (_challengeParameters$ = challengeParameters === null || challengeParameters === void 0 ? void 0 : challengeParameters.USERNAME) !== null && _challengeParameters$ !== void 0 ? _challengeParameters$ : username;\n  setActiveSignInUsername(activeUsername);\n  return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [password, challengeParameters, clientMetadata, session, authenticationHelper, config, tokenOrchestrator], activeUsername, tokenOrchestrator);\n}\nasync function getSignInResult(params) {\n  var _Amplify$getConfig$Au;\n  const {\n    challengeName,\n    challengeParameters,\n    availableChallenges\n  } = params;\n  const authConfig = (_Amplify$getConfig$Au = Amplify.getConfig().Auth) === null || _Amplify$getConfig$Au === void 0 ? void 0 : _Amplify$getConfig$Au.Cognito;\n  assertTokenProviderConfig(authConfig);\n  switch (challengeName) {\n    case 'CUSTOM_CHALLENGE':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE',\n          additionalInfo: challengeParameters\n        }\n      };\n    case 'MFA_SETUP':\n      {\n        const {\n          signInSession,\n          username\n        } = signInStore.getState();\n        const mfaSetupTypes = getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_SETUP)) || [];\n        const allowedMfaSetupTypes = getAllowedMfaSetupTypes(mfaSetupTypes);\n        const isTotpMfaSetupAvailable = allowedMfaSetupTypes.includes('TOTP');\n        const isEmailMfaSetupAvailable = allowedMfaSetupTypes.includes('EMAIL');\n        if (isTotpMfaSetupAvailable && isEmailMfaSetupAvailable) {\n          return {\n            isSignedIn: false,\n            nextStep: {\n              signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION',\n              allowedMFATypes: allowedMfaSetupTypes\n            }\n          };\n        }\n        if (isEmailMfaSetupAvailable) {\n          return {\n            isSignedIn: false,\n            nextStep: {\n              signInStep: 'CONTINUE_SIGN_IN_WITH_EMAIL_SETUP'\n            }\n          };\n        }\n        if (isTotpMfaSetupAvailable) {\n          const associateSoftwareToken = createAssociateSoftwareTokenClient({\n            endpointResolver: createCognitoUserPoolEndpointResolver({\n              endpointOverride: authConfig.userPoolEndpoint\n            })\n          });\n          const {\n            Session,\n            SecretCode: secretCode\n          } = await associateSoftwareToken({\n            region: getRegionFromUserPoolId(authConfig.userPoolId)\n          }, {\n            Session: signInSession\n          });\n          signInStore.dispatch({\n            type: 'SET_SIGN_IN_SESSION',\n            value: Session\n          });\n          return {\n            isSignedIn: false,\n            nextStep: {\n              signInStep: 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP',\n              totpSetupDetails: getTOTPSetupDetails(secretCode, username)\n            }\n          };\n        }\n        throw new AuthError({\n          name: AuthErrorCodes.SignInException,\n          message: \"Cannot initiate MFA setup from available types: \".concat(mfaSetupTypes)\n        });\n      }\n    case 'NEW_PASSWORD_REQUIRED':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED',\n          missingAttributes: parseAttributes(challengeParameters.requiredAttributes)\n        }\n      };\n    case 'SELECT_MFA_TYPE':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION',\n          allowedMFATypes: getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_CHOOSE))\n        }\n      };\n    case 'SMS_OTP':\n    case 'SMS_MFA':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_SMS_CODE',\n          codeDeliveryDetails: {\n            deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n            destination: challengeParameters.CODE_DELIVERY_DESTINATION\n          }\n        }\n      };\n    case 'SOFTWARE_TOKEN_MFA':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_TOTP_CODE'\n        }\n      };\n    case 'EMAIL_OTP':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE',\n          codeDeliveryDetails: {\n            deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n            destination: challengeParameters.CODE_DELIVERY_DESTINATION\n          }\n        }\n      };\n    case 'WEB_AUTHN':\n      {\n        const result = await handleWebAuthnSignInResult(challengeParameters);\n        if (isWebAuthnResultAuthSignInOutput(result)) {\n          return result;\n        }\n        return getSignInResult(result);\n      }\n    case 'PASSWORD':\n    case 'PASSWORD_SRP':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONFIRM_SIGN_IN_WITH_PASSWORD'\n        }\n      };\n    case 'SELECT_CHALLENGE':\n      return {\n        isSignedIn: false,\n        nextStep: {\n          signInStep: 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION',\n          availableChallenges\n        }\n      };\n  }\n  // TODO: remove this error message for production apps\n  throw new AuthError({\n    name: AuthErrorCodes.SignInException,\n    message: 'An error occurred during the sign in process. ' + \"\".concat(challengeName, \" challengeName returned by the underlying service was not addressed.\")\n  });\n}\nfunction getTOTPSetupDetails(secretCode, username) {\n  return {\n    sharedSecret: secretCode,\n    getSetupUri: (appName, accountName) => {\n      const totpUri = \"otpauth://totp/\".concat(appName, \":\").concat(accountName !== null && accountName !== void 0 ? accountName : username, \"?secret=\").concat(secretCode, \"&issuer=\").concat(appName);\n      return new AmplifyUrl(totpUri);\n    }\n  };\n}\nfunction getSignInResultFromError(errorName) {\n  if (errorName === InitiateAuthException.PasswordResetRequiredException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'RESET_PASSWORD'\n      }\n    };\n  } else if (errorName === InitiateAuthException.UserNotConfirmedException) {\n    return {\n      isSignedIn: false,\n      nextStep: {\n        signInStep: 'CONFIRM_SIGN_UP'\n      }\n    };\n  }\n}\nfunction parseAttributes(attributes) {\n  if (!attributes) return [];\n  const parsedAttributes = JSON.parse(attributes).map(att => att.includes(USER_ATTRIBUTES) ? att.replace(USER_ATTRIBUTES, '') : att);\n  return parsedAttributes;\n}\nfunction createAttributes(attributes) {\n  if (!attributes) return {};\n  const newAttributes = {};\n  Object.entries(attributes).forEach(_ref6 => {\n    let [key, value] = _ref6;\n    if (value) newAttributes[\"\".concat(USER_ATTRIBUTES).concat(key)] = value;\n  });\n  return newAttributes;\n}\nasync function handleChallengeName(username, challengeName, session, challengeResponse, config, tokenOrchestrator, clientMetadata, options) {\n  const userAttributes = options === null || options === void 0 ? void 0 : options.userAttributes;\n  const deviceName = options === null || options === void 0 ? void 0 : options.friendlyDeviceName;\n  switch (challengeName) {\n    case 'WEB_AUTHN':\n    case 'SELECT_CHALLENGE':\n      if (challengeResponse === 'PASSWORD_SRP' || challengeResponse === 'PASSWORD') {\n        return {\n          ChallengeName: challengeResponse,\n          Session: session,\n          $metadata: {}\n        };\n      }\n      return initiateSelectedChallenge({\n        username,\n        session,\n        selectedChallenge: challengeResponse,\n        config,\n        clientMetadata\n      });\n    case 'SELECT_MFA_TYPE':\n      return handleSelectMFATypeChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config\n      });\n    case 'MFA_SETUP':\n      return handleMFASetupChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        deviceName,\n        config\n      });\n    case 'NEW_PASSWORD_REQUIRED':\n      return handleCompleteNewPasswordChallenge({\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        requiredAttributes: userAttributes,\n        config\n      });\n    case 'CUSTOM_CHALLENGE':\n      return retryOnResourceNotFoundException(handleCustomChallenge, [{\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config,\n        tokenOrchestrator\n      }], username, tokenOrchestrator);\n    case 'SMS_MFA':\n    case 'SOFTWARE_TOKEN_MFA':\n    case 'SMS_OTP':\n    case 'EMAIL_OTP':\n      return handleMFAChallenge({\n        challengeName,\n        challengeResponse,\n        clientMetadata,\n        session,\n        username,\n        config\n      });\n    case 'PASSWORD':\n      return handleSelectChallengeWithPassword(username, challengeResponse, clientMetadata, config, session);\n    case 'PASSWORD_SRP':\n      return handleSelectChallengeWithPasswordSRP(username, challengeResponse,\n      // This is the actual password\n      clientMetadata, config, session, tokenOrchestrator);\n  }\n  // TODO: remove this error message for production apps\n  throw new AuthError({\n    name: AuthErrorCodes.SignInException,\n    message: \"An error occurred during the sign in process.\\n\\t\\t\".concat(challengeName, \" challengeName returned by the underlying service was not addressed.\")\n  });\n}\nfunction mapMfaType(mfa) {\n  let mfaType = 'SMS_MFA';\n  if (mfa === 'TOTP') mfaType = 'SOFTWARE_TOKEN_MFA';\n  if (mfa === 'EMAIL') mfaType = 'EMAIL_OTP';\n  return mfaType;\n}\nfunction getMFAType(type) {\n  if (type === 'SMS_MFA') return 'SMS';\n  if (type === 'SOFTWARE_TOKEN_MFA') return 'TOTP';\n  if (type === 'EMAIL_OTP') return 'EMAIL';\n  // TODO: log warning for unknown MFA type\n}\nfunction getMFATypes(types) {\n  if (!types) return undefined;\n  return types.map(getMFAType).filter(Boolean);\n}\nfunction parseMFATypes(mfa) {\n  if (!mfa) return [];\n  return JSON.parse(mfa);\n}\nfunction getAllowedMfaSetupTypes(availableMfaSetupTypes) {\n  return availableMfaSetupTypes.filter(authMfaType => authMfaType === 'EMAIL' || authMfaType === 'TOTP');\n}\nasync function assertUserNotAuthenticated() {\n  let authUser;\n  try {\n    authUser = await getCurrentUser();\n  } catch (error) {}\n  if (authUser && authUser.userId && authUser.username) {\n    throw new AuthError({\n      name: USER_ALREADY_AUTHENTICATED_EXCEPTION,\n      message: 'There is already a signed in user.',\n      recoverySuggestion: 'Call signOut before calling signIn again.'\n    });\n  }\n}\nfunction getActiveSignInUsername(username) {\n  var _state$username;\n  const state = signInStore.getState();\n  return (_state$username = state.username) !== null && _state$username !== void 0 ? _state$username : username;\n}\nasync function handleMFAChallenge(_ref7) {\n  let {\n    challengeName,\n    challengeResponse,\n    clientMetadata,\n    session,\n    username,\n    config\n  } = _ref7;\n  const {\n    userPoolId,\n    userPoolClientId,\n    userPoolEndpoint\n  } = config;\n  const challengeResponses = {\n    USERNAME: username\n  };\n  if (challengeName === 'EMAIL_OTP') {\n    challengeResponses.EMAIL_OTP_CODE = challengeResponse;\n  }\n  if (challengeName === 'SMS_MFA') {\n    challengeResponses.SMS_MFA_CODE = challengeResponse;\n  }\n  if (challengeName === 'SMS_OTP') {\n    challengeResponses.SMS_OTP_CODE = challengeResponse;\n  }\n  if (challengeName === 'SOFTWARE_TOKEN_MFA') {\n    challengeResponses.SOFTWARE_TOKEN_MFA_CODE = challengeResponse;\n  }\n  const userContextData = getUserContextData({\n    username,\n    userPoolId,\n    userPoolClientId\n  });\n  const jsonReq = {\n    ChallengeName: challengeName,\n    ChallengeResponses: challengeResponses,\n    Session: session,\n    ClientMetadata: clientMetadata,\n    ClientId: userPoolClientId,\n    UserContextData: userContextData\n  };\n  const respondToAuthChallenge = createRespondToAuthChallengeClient({\n    endpointResolver: createCognitoUserPoolEndpointResolver({\n      endpointOverride: userPoolEndpoint\n    })\n  });\n  return respondToAuthChallenge({\n    region: getRegionFromUserPoolId(userPoolId),\n    userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn)\n  }, jsonReq);\n}\nexport { assertUserNotAuthenticated, createAttributes, getActiveSignInUsername, getAllowedMfaSetupTypes, getMFAType, getMFATypes, getSignInResult, getSignInResultFromError, getTOTPSetupDetails, handleChallengeName, handleCompleteNewPasswordChallenge, handleCustomAuthFlowWithoutSRP, handleCustomChallenge, handleCustomSRPAuthFlow, handleMFAChallenge, handleMFASetupChallenge, handleSelectMFATypeChallenge, handleUserPasswordAuthFlow, handleUserSRPAuthFlow, mapMfaType, parseAttributes, parseMFATypes };","map":{"version":3,"names":["USER_ATTRIBUTES","isWebAuthnResultAuthSignInOutput","result","handleCustomChallenge","_ref","challengeResponse","clientMetadata","session","username","config","tokenOrchestrator","userPoolId","userPoolClientId","userPoolEndpoint","challengeResponses","USERNAME","ANSWER","deviceMetadata","getDeviceMetadata","deviceKey","DEVICE_KEY","UserContextData","getUserContextData","jsonReq","ChallengeName","ChallengeResponses","Session","ClientMetadata","ClientId","respondToAuthChallenge","createRespondToAuthChallengeClient","endpointResolver","createCognitoUserPoolEndpointResolver","endpointOverride","response","region","getRegionFromUserPoolId","userAgentValue","getAuthUserAgentValue","AuthAction","ConfirmSignIn","handleDeviceSRPAuth","handleMFASetupChallenge","_ref2","deviceName","ChallengeParameters","MFAS_CAN_SETUP","$metadata","isTOTPCode","test","verifySoftwareToken","createVerifySoftwareTokenClient","UserCode","FriendlyDeviceName","signInStore","dispatch","type","value","isEmail","includes","EMAIL","AuthError","name","AuthErrorCodes","SignInException","message","concat","recoverySuggestion","handleSelectMFATypeChallenge","_ref3","assertValidationError","AuthValidationErrorCode","IncorrectMFAMethod","mapMfaType","handleCompleteNewPasswordChallenge","_ref4","requiredAttributes","_objectSpread","createAttributes","NEW_PASSWORD","handleUserPasswordAuthFlow","password","_ref5","_response$ChallengePa","_response$ChallengePa2","_response$ChallengePa3","authParameters","PASSWORD","AuthFlow","AuthParameters","initiateAuth","createInitiateAuthClient","SignIn","activeUsername","USER_ID_FOR_SRP","setActiveSignInUsername","handleUserSRPAuthFlow","handlePasswordSRP","authFlow","handleCustomAuthFlowWithoutSRP","_response$ChallengePa4","_response$ChallengePa5","handleCustomSRPAuthFlow","_challengeParameters$","assertTokenProviderConfig","userPoolName","split","authenticationHelper","getAuthenticationHelper","SRP_A","A","toString","CHALLENGE_NAME","challengeParameters","retryOnResourceNotFoundException","handlePasswordVerifierChallenge","getSignInResult","params","_Amplify$getConfig$Au","challengeName","availableChallenges","authConfig","Amplify","getConfig","Auth","Cognito","isSignedIn","nextStep","signInStep","additionalInfo","signInSession","getState","mfaSetupTypes","getMFATypes","parseMFATypes","allowedMfaSetupTypes","getAllowedMfaSetupTypes","isTotpMfaSetupAvailable","isEmailMfaSetupAvailable","allowedMFATypes","associateSoftwareToken","createAssociateSoftwareTokenClient","SecretCode","secretCode","totpSetupDetails","getTOTPSetupDetails","missingAttributes","parseAttributes","MFAS_CAN_CHOOSE","codeDeliveryDetails","deliveryMedium","CODE_DELIVERY_DELIVERY_MEDIUM","destination","CODE_DELIVERY_DESTINATION","handleWebAuthnSignInResult","sharedSecret","getSetupUri","appName","accountName","totpUri","AmplifyUrl","getSignInResultFromError","errorName","InitiateAuthException","PasswordResetRequiredException","UserNotConfirmedException","attributes","parsedAttributes","JSON","parse","map","att","replace","newAttributes","Object","entries","forEach","_ref6","key","handleChallengeName","options","userAttributes","friendlyDeviceName","initiateSelectedChallenge","selectedChallenge","handleMFAChallenge","handleSelectChallengeWithPassword","handleSelectChallengeWithPasswordSRP","mfa","mfaType","getMFAType","types","undefined","filter","Boolean","availableMfaSetupTypes","authMfaType","assertUserNotAuthenticated","authUser","getCurrentUser","error","userId","USER_ALREADY_AUTHENTICATED_EXCEPTION","getActiveSignInUsername","_state$username","state","_ref7","EMAIL_OTP_CODE","SMS_MFA_CODE","SMS_OTP_CODE","SOFTWARE_TOKEN_MFA_CODE","userContextData"],"sources":["/home/truongnvops/Documents/Project_AWS/tdhva-cooksocial/frontend/node_modules/@aws-amplify/auth/src/providers/cognito/utils/signInHelpers.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify } from '@aws-amplify/core';\nimport { AmplifyUrl, AuthAction, assertTokenProviderConfig, } from '@aws-amplify/core/internals/utils';\nimport { AuthError } from '../../../errors/AuthError';\nimport { InitiateAuthException } from '../types/errors';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings';\nimport { AuthValidationErrorCode } from '../../../errors/types/validation';\nimport { assertValidationError } from '../../../errors/utils/assertValidationError';\nimport { USER_ALREADY_AUTHENTICATED_EXCEPTION } from '../../../errors/constants';\nimport { getCurrentUser } from '../apis/getCurrentUser';\nimport { getAuthUserAgentValue } from '../../../utils';\nimport { createAssociateSoftwareTokenClient, createInitiateAuthClient, createRespondToAuthChallengeClient, createVerifySoftwareTokenClient, } from '../../../foundation/factories/serviceClients/cognitoIdentityProvider';\nimport { createCognitoUserPoolEndpointResolver } from '../factories';\nimport { getRegionFromUserPoolId } from '../../../foundation/parsers';\nimport { handleWebAuthnSignInResult } from '../../../client/flows/userAuth/handleWebAuthnSignInResult';\nimport { handlePasswordSRP } from '../../../client/flows/shared/handlePasswordSRP';\nimport { initiateSelectedChallenge } from '../../../client/flows/userAuth/handleSelectChallenge';\nimport { handleSelectChallengeWithPassword } from '../../../client/flows/userAuth/handleSelectChallengeWithPassword';\nimport { handleSelectChallengeWithPasswordSRP } from '../../../client/flows/userAuth/handleSelectChallengeWithPasswordSRP';\nimport { signInStore } from '../../../client/utils/store';\nimport { getAuthenticationHelper } from './srp';\nimport { getUserContextData } from './userContextData';\nimport { handlePasswordVerifierChallenge } from './handlePasswordVerifierChallenge';\nimport { handleDeviceSRPAuth } from './handleDeviceSRPAuth';\nimport { retryOnResourceNotFoundException } from './retryOnResourceNotFoundException';\nimport { setActiveSignInUsername } from './setActiveSignInUsername';\nconst USER_ATTRIBUTES = 'userAttributes.';\nfunction isWebAuthnResultAuthSignInOutput(result) {\n    return 'isSignedIn' in result && 'nextStep' in result;\n}\nexport async function handleCustomChallenge({ challengeResponse, clientMetadata, session, username, config, tokenOrchestrator, }) {\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    const challengeResponses = {\n        USERNAME: username,\n        ANSWER: challengeResponse,\n    };\n    const deviceMetadata = await tokenOrchestrator?.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        challengeResponses.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'CUSTOM_CHALLENGE',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    const response = await respondToAuthChallenge({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH') {\n        return handleDeviceSRPAuth({\n            username,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    }\n    return response;\n}\nexport async function handleMFASetupChallenge({ challengeResponse, username, clientMetadata, session, deviceName, config, }) {\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    if (challengeResponse === 'EMAIL') {\n        return {\n            ChallengeName: 'MFA_SETUP',\n            Session: session,\n            ChallengeParameters: {\n                MFAS_CAN_SETUP: '[\"EMAIL_OTP\"]',\n            },\n            $metadata: {},\n        };\n    }\n    if (challengeResponse === 'TOTP') {\n        return {\n            ChallengeName: 'MFA_SETUP',\n            Session: session,\n            ChallengeParameters: {\n                MFAS_CAN_SETUP: '[\"SOFTWARE_TOKEN_MFA\"]',\n            },\n            $metadata: {},\n        };\n    }\n    const challengeResponses = {\n        USERNAME: username,\n    };\n    const isTOTPCode = /^\\d+$/.test(challengeResponse);\n    if (isTOTPCode) {\n        const verifySoftwareToken = createVerifySoftwareTokenClient({\n            endpointResolver: createCognitoUserPoolEndpointResolver({\n                endpointOverride: userPoolEndpoint,\n            }),\n        });\n        const { Session } = await verifySoftwareToken({\n            region: getRegionFromUserPoolId(userPoolId),\n            userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n        }, {\n            UserCode: challengeResponse,\n            Session: session,\n            FriendlyDeviceName: deviceName,\n        });\n        signInStore.dispatch({\n            type: 'SET_SIGN_IN_SESSION',\n            value: Session,\n        });\n        const jsonReq = {\n            ChallengeName: 'MFA_SETUP',\n            ChallengeResponses: challengeResponses,\n            Session,\n            ClientMetadata: clientMetadata,\n            ClientId: userPoolClientId,\n        };\n        const respondToAuthChallenge = createRespondToAuthChallengeClient({\n            endpointResolver: createCognitoUserPoolEndpointResolver({\n                endpointOverride: userPoolEndpoint,\n            }),\n        });\n        return respondToAuthChallenge({\n            region: getRegionFromUserPoolId(userPoolId),\n            userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n        }, jsonReq);\n    }\n    const isEmail = challengeResponse.includes('@');\n    if (isEmail) {\n        challengeResponses.EMAIL = challengeResponse;\n        const jsonReq = {\n            ChallengeName: 'MFA_SETUP',\n            ChallengeResponses: challengeResponses,\n            Session: session,\n            ClientMetadata: clientMetadata,\n            ClientId: userPoolClientId,\n        };\n        const respondToAuthChallenge = createRespondToAuthChallengeClient({\n            endpointResolver: createCognitoUserPoolEndpointResolver({\n                endpointOverride: userPoolEndpoint,\n            }),\n        });\n        return respondToAuthChallenge({\n            region: getRegionFromUserPoolId(userPoolId),\n            userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n        }, jsonReq);\n    }\n    throw new AuthError({\n        name: AuthErrorCodes.SignInException,\n        message: `Cannot proceed with MFA setup using challengeResponse: ${challengeResponse}`,\n        recoverySuggestion: 'Try passing \"EMAIL\", \"TOTP\", a valid email, or OTP code as the challengeResponse.',\n    });\n}\nexport async function handleSelectMFATypeChallenge({ challengeResponse, username, clientMetadata, session, config, }) {\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    assertValidationError(challengeResponse === 'TOTP' ||\n        challengeResponse === 'SMS' ||\n        challengeResponse === 'EMAIL', AuthValidationErrorCode.IncorrectMFAMethod);\n    const challengeResponses = {\n        USERNAME: username,\n        ANSWER: mapMfaType(challengeResponse),\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'SELECT_MFA_TYPE',\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    return respondToAuthChallenge({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleCompleteNewPasswordChallenge({ challengeResponse, clientMetadata, session, username, requiredAttributes, config, }) {\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    const challengeResponses = {\n        ...createAttributes(requiredAttributes),\n        NEW_PASSWORD: challengeResponse,\n        USERNAME: username,\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: 'NEW_PASSWORD_REQUIRED',\n        ChallengeResponses: challengeResponses,\n        ClientMetadata: clientMetadata,\n        Session: session,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    return respondToAuthChallenge({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\nexport async function handleUserPasswordAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    const { userPoolClientId, userPoolId, userPoolEndpoint } = config;\n    const authParameters = {\n        USERNAME: username,\n        PASSWORD: password,\n    };\n    const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'USER_PASSWORD_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const initiateAuth = createInitiateAuthClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    const response = await initiateAuth({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ??\n        response.ChallengeParameters?.USER_ID_FOR_SRP ??\n        username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH')\n        return handleDeviceSRPAuth({\n            username: activeUsername,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    return response;\n}\nexport async function handleUserSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    return handlePasswordSRP({\n        username,\n        password,\n        clientMetadata,\n        config,\n        tokenOrchestrator,\n        authFlow: 'USER_SRP_AUTH',\n    });\n}\nexport async function handleCustomAuthFlowWithoutSRP(username, clientMetadata, config, tokenOrchestrator) {\n    const { userPoolClientId, userPoolId, userPoolEndpoint } = config;\n    const authParameters = {\n        USERNAME: username,\n    };\n    const deviceMetadata = await tokenOrchestrator.getDeviceMetadata(username);\n    if (deviceMetadata && deviceMetadata.deviceKey) {\n        authParameters.DEVICE_KEY = deviceMetadata.deviceKey;\n    }\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'CUSTOM_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const initiateAuth = createInitiateAuthClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    const response = await initiateAuth({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = response.ChallengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    if (response.ChallengeName === 'DEVICE_SRP_AUTH')\n        return handleDeviceSRPAuth({\n            username: activeUsername,\n            config,\n            clientMetadata,\n            session: response.Session,\n            tokenOrchestrator,\n        });\n    return response;\n}\nexport async function handleCustomSRPAuthFlow(username, password, clientMetadata, config, tokenOrchestrator) {\n    assertTokenProviderConfig(config);\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    const userPoolName = userPoolId?.split('_')[1] || '';\n    const authenticationHelper = await getAuthenticationHelper(userPoolName);\n    const authParameters = {\n        USERNAME: username,\n        SRP_A: authenticationHelper.A.toString(16),\n        CHALLENGE_NAME: 'SRP_A',\n    };\n    const UserContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        AuthFlow: 'CUSTOM_AUTH',\n        AuthParameters: authParameters,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData,\n    };\n    const initiateAuth = createInitiateAuthClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    const { ChallengeParameters: challengeParameters, Session: session } = await initiateAuth({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.SignIn),\n    }, jsonReq);\n    const activeUsername = challengeParameters?.USERNAME ?? username;\n    setActiveSignInUsername(activeUsername);\n    return retryOnResourceNotFoundException(handlePasswordVerifierChallenge, [\n        password,\n        challengeParameters,\n        clientMetadata,\n        session,\n        authenticationHelper,\n        config,\n        tokenOrchestrator,\n    ], activeUsername, tokenOrchestrator);\n}\nexport async function getSignInResult(params) {\n    const { challengeName, challengeParameters, availableChallenges } = params;\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    switch (challengeName) {\n        case 'CUSTOM_CHALLENGE':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE',\n                    additionalInfo: challengeParameters,\n                },\n            };\n        case 'MFA_SETUP': {\n            const { signInSession, username } = signInStore.getState();\n            const mfaSetupTypes = getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_SETUP)) || [];\n            const allowedMfaSetupTypes = getAllowedMfaSetupTypes(mfaSetupTypes);\n            const isTotpMfaSetupAvailable = allowedMfaSetupTypes.includes('TOTP');\n            const isEmailMfaSetupAvailable = allowedMfaSetupTypes.includes('EMAIL');\n            if (isTotpMfaSetupAvailable && isEmailMfaSetupAvailable) {\n                return {\n                    isSignedIn: false,\n                    nextStep: {\n                        signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION',\n                        allowedMFATypes: allowedMfaSetupTypes,\n                    },\n                };\n            }\n            if (isEmailMfaSetupAvailable) {\n                return {\n                    isSignedIn: false,\n                    nextStep: {\n                        signInStep: 'CONTINUE_SIGN_IN_WITH_EMAIL_SETUP',\n                    },\n                };\n            }\n            if (isTotpMfaSetupAvailable) {\n                const associateSoftwareToken = createAssociateSoftwareTokenClient({\n                    endpointResolver: createCognitoUserPoolEndpointResolver({\n                        endpointOverride: authConfig.userPoolEndpoint,\n                    }),\n                });\n                const { Session, SecretCode: secretCode } = await associateSoftwareToken({ region: getRegionFromUserPoolId(authConfig.userPoolId) }, {\n                    Session: signInSession,\n                });\n                signInStore.dispatch({\n                    type: 'SET_SIGN_IN_SESSION',\n                    value: Session,\n                });\n                return {\n                    isSignedIn: false,\n                    nextStep: {\n                        signInStep: 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP',\n                        totpSetupDetails: getTOTPSetupDetails(secretCode, username),\n                    },\n                };\n            }\n            throw new AuthError({\n                name: AuthErrorCodes.SignInException,\n                message: `Cannot initiate MFA setup from available types: ${mfaSetupTypes}`,\n            });\n        }\n        case 'NEW_PASSWORD_REQUIRED':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED',\n                    missingAttributes: parseAttributes(challengeParameters.requiredAttributes),\n                },\n            };\n        case 'SELECT_MFA_TYPE':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION',\n                    allowedMFATypes: getMFATypes(parseMFATypes(challengeParameters.MFAS_CAN_CHOOSE)),\n                },\n            };\n        case 'SMS_OTP':\n        case 'SMS_MFA':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_SMS_CODE',\n                    codeDeliveryDetails: {\n                        deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n                        destination: challengeParameters.CODE_DELIVERY_DESTINATION,\n                    },\n                },\n            };\n        case 'SOFTWARE_TOKEN_MFA':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_TOTP_CODE',\n                },\n            };\n        case 'EMAIL_OTP':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE',\n                    codeDeliveryDetails: {\n                        deliveryMedium: challengeParameters.CODE_DELIVERY_DELIVERY_MEDIUM,\n                        destination: challengeParameters.CODE_DELIVERY_DESTINATION,\n                    },\n                },\n            };\n        case 'WEB_AUTHN': {\n            const result = await handleWebAuthnSignInResult(challengeParameters);\n            if (isWebAuthnResultAuthSignInOutput(result)) {\n                return result;\n            }\n            return getSignInResult(result);\n        }\n        case 'PASSWORD':\n        case 'PASSWORD_SRP':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONFIRM_SIGN_IN_WITH_PASSWORD',\n                },\n            };\n        case 'SELECT_CHALLENGE':\n            return {\n                isSignedIn: false,\n                nextStep: {\n                    signInStep: 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION',\n                    availableChallenges,\n                },\n            };\n        case 'ADMIN_NO_SRP_AUTH':\n            break;\n        case 'DEVICE_PASSWORD_VERIFIER':\n            break;\n        case 'DEVICE_SRP_AUTH':\n            break;\n        case 'PASSWORD_VERIFIER':\n            break;\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n        name: AuthErrorCodes.SignInException,\n        message: 'An error occurred during the sign in process. ' +\n            `${challengeName} challengeName returned by the underlying service was not addressed.`,\n    });\n}\nexport function getTOTPSetupDetails(secretCode, username) {\n    return {\n        sharedSecret: secretCode,\n        getSetupUri: (appName, accountName) => {\n            const totpUri = `otpauth://totp/${appName}:${accountName ?? username}?secret=${secretCode}&issuer=${appName}`;\n            return new AmplifyUrl(totpUri);\n        },\n    };\n}\nexport function getSignInResultFromError(errorName) {\n    if (errorName === InitiateAuthException.PasswordResetRequiredException) {\n        return {\n            isSignedIn: false,\n            nextStep: { signInStep: 'RESET_PASSWORD' },\n        };\n    }\n    else if (errorName === InitiateAuthException.UserNotConfirmedException) {\n        return {\n            isSignedIn: false,\n            nextStep: { signInStep: 'CONFIRM_SIGN_UP' },\n        };\n    }\n}\nexport function parseAttributes(attributes) {\n    if (!attributes)\n        return [];\n    const parsedAttributes = JSON.parse(attributes).map(att => att.includes(USER_ATTRIBUTES) ? att.replace(USER_ATTRIBUTES, '') : att);\n    return parsedAttributes;\n}\nexport function createAttributes(attributes) {\n    if (!attributes)\n        return {};\n    const newAttributes = {};\n    Object.entries(attributes).forEach(([key, value]) => {\n        if (value)\n            newAttributes[`${USER_ATTRIBUTES}${key}`] = value;\n    });\n    return newAttributes;\n}\nexport async function handleChallengeName(username, challengeName, session, challengeResponse, config, tokenOrchestrator, clientMetadata, options) {\n    const userAttributes = options?.userAttributes;\n    const deviceName = options?.friendlyDeviceName;\n    switch (challengeName) {\n        case 'WEB_AUTHN':\n        case 'SELECT_CHALLENGE':\n            if (challengeResponse === 'PASSWORD_SRP' ||\n                challengeResponse === 'PASSWORD') {\n                return {\n                    ChallengeName: challengeResponse,\n                    Session: session,\n                    $metadata: {},\n                };\n            }\n            return initiateSelectedChallenge({\n                username,\n                session,\n                selectedChallenge: challengeResponse,\n                config,\n                clientMetadata,\n            });\n        case 'SELECT_MFA_TYPE':\n            return handleSelectMFATypeChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                config,\n            });\n        case 'MFA_SETUP':\n            return handleMFASetupChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                deviceName,\n                config,\n            });\n        case 'NEW_PASSWORD_REQUIRED':\n            return handleCompleteNewPasswordChallenge({\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                requiredAttributes: userAttributes,\n                config,\n            });\n        case 'CUSTOM_CHALLENGE':\n            return retryOnResourceNotFoundException(handleCustomChallenge, [\n                {\n                    challengeResponse,\n                    clientMetadata,\n                    session,\n                    username,\n                    config,\n                    tokenOrchestrator,\n                },\n            ], username, tokenOrchestrator);\n        case 'SMS_MFA':\n        case 'SOFTWARE_TOKEN_MFA':\n        case 'SMS_OTP':\n        case 'EMAIL_OTP':\n            return handleMFAChallenge({\n                challengeName,\n                challengeResponse,\n                clientMetadata,\n                session,\n                username,\n                config,\n            });\n        case 'PASSWORD':\n            return handleSelectChallengeWithPassword(username, challengeResponse, clientMetadata, config, session);\n        case 'PASSWORD_SRP':\n            return handleSelectChallengeWithPasswordSRP(username, challengeResponse, // This is the actual password\n            clientMetadata, config, session, tokenOrchestrator);\n    }\n    // TODO: remove this error message for production apps\n    throw new AuthError({\n        name: AuthErrorCodes.SignInException,\n        message: `An error occurred during the sign in process.\n\t\t${challengeName} challengeName returned by the underlying service was not addressed.`,\n    });\n}\nexport function mapMfaType(mfa) {\n    let mfaType = 'SMS_MFA';\n    if (mfa === 'TOTP')\n        mfaType = 'SOFTWARE_TOKEN_MFA';\n    if (mfa === 'EMAIL')\n        mfaType = 'EMAIL_OTP';\n    return mfaType;\n}\nexport function getMFAType(type) {\n    if (type === 'SMS_MFA')\n        return 'SMS';\n    if (type === 'SOFTWARE_TOKEN_MFA')\n        return 'TOTP';\n    if (type === 'EMAIL_OTP')\n        return 'EMAIL';\n    // TODO: log warning for unknown MFA type\n}\nexport function getMFATypes(types) {\n    if (!types)\n        return undefined;\n    return types.map(getMFAType).filter(Boolean);\n}\nexport function parseMFATypes(mfa) {\n    if (!mfa)\n        return [];\n    return JSON.parse(mfa);\n}\nexport function getAllowedMfaSetupTypes(availableMfaSetupTypes) {\n    return availableMfaSetupTypes.filter(authMfaType => authMfaType === 'EMAIL' || authMfaType === 'TOTP');\n}\nexport async function assertUserNotAuthenticated() {\n    let authUser;\n    try {\n        authUser = await getCurrentUser();\n    }\n    catch (error) { }\n    if (authUser && authUser.userId && authUser.username) {\n        throw new AuthError({\n            name: USER_ALREADY_AUTHENTICATED_EXCEPTION,\n            message: 'There is already a signed in user.',\n            recoverySuggestion: 'Call signOut before calling signIn again.',\n        });\n    }\n}\nexport function getActiveSignInUsername(username) {\n    const state = signInStore.getState();\n    return state.username ?? username;\n}\nexport async function handleMFAChallenge({ challengeName, challengeResponse, clientMetadata, session, username, config, }) {\n    const { userPoolId, userPoolClientId, userPoolEndpoint } = config;\n    const challengeResponses = {\n        USERNAME: username,\n    };\n    if (challengeName === 'EMAIL_OTP') {\n        challengeResponses.EMAIL_OTP_CODE = challengeResponse;\n    }\n    if (challengeName === 'SMS_MFA') {\n        challengeResponses.SMS_MFA_CODE = challengeResponse;\n    }\n    if (challengeName === 'SMS_OTP') {\n        challengeResponses.SMS_OTP_CODE = challengeResponse;\n    }\n    if (challengeName === 'SOFTWARE_TOKEN_MFA') {\n        challengeResponses.SOFTWARE_TOKEN_MFA_CODE = challengeResponse;\n    }\n    const userContextData = getUserContextData({\n        username,\n        userPoolId,\n        userPoolClientId,\n    });\n    const jsonReq = {\n        ChallengeName: challengeName,\n        ChallengeResponses: challengeResponses,\n        Session: session,\n        ClientMetadata: clientMetadata,\n        ClientId: userPoolClientId,\n        UserContextData: userContextData,\n    };\n    const respondToAuthChallenge = createRespondToAuthChallengeClient({\n        endpointResolver: createCognitoUserPoolEndpointResolver({\n            endpointOverride: userPoolEndpoint,\n        }),\n    });\n    return respondToAuthChallenge({\n        region: getRegionFromUserPoolId(userPoolId),\n        userAgentValue: getAuthUserAgentValue(AuthAction.ConfirmSignIn),\n    }, jsonReq);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}