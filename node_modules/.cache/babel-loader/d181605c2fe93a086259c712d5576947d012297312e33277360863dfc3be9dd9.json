{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Returns a canonical query string.\n *\n * @param searchParams `searchParams` from the request url.\n * @returns URL-encoded query string parameters, separated by ampersands (&). Percent-encode reserved characters,\n * including the space character. Encode names and values separately. If there are empty parameters, append the equals\n * sign to the parameter name before encoding. After encoding, sort the parameters alphabetically by key name. If there\n * is no query string, use an empty string (\"\").\n *\n * @internal\n */\nconst getCanonicalQueryString = searchParams => Array.from(searchParams).sort((_ref, _ref2) => {\n  let [keyA, valA] = _ref;\n  let [keyB, valB] = _ref2;\n  if (keyA === keyB) {\n    return valA < valB ? -1 : 1;\n  }\n  return keyA < keyB ? -1 : 1;\n}).map(_ref3 => {\n  let [key, val] = _ref3;\n  return \"\".concat(escapeUri(key), \"=\").concat(escapeUri(val));\n}).join('&');\nconst escapeUri = uri => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);\nconst hexEncode = c => \"%\".concat(c.charCodeAt(0).toString(16).toUpperCase());\nexport { getCanonicalQueryString };","map":{"version":3,"names":["getCanonicalQueryString","searchParams","Array","from","sort","_ref","_ref2","keyA","valA","keyB","valB","map","_ref3","key","val","concat","escapeUri","join","uri","encodeURIComponent","replace","hexEncode","c","charCodeAt","toString","toUpperCase"],"sources":["/home/truongnvops/Documents/Project_AWS/tdhva-cooksocial/frontend/node_modules/@aws-amplify/core/src/clients/middleware/signing/signer/signatureV4/utils/getCanonicalQueryString.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Returns a canonical query string.\n *\n * @param searchParams `searchParams` from the request url.\n * @returns URL-encoded query string parameters, separated by ampersands (&). Percent-encode reserved characters,\n * including the space character. Encode names and values separately. If there are empty parameters, append the equals\n * sign to the parameter name before encoding. After encoding, sort the parameters alphabetically by key name. If there\n * is no query string, use an empty string (\"\").\n *\n * @internal\n */\nexport const getCanonicalQueryString = (searchParams) => Array.from(searchParams)\n    .sort(([keyA, valA], [keyB, valB]) => {\n    if (keyA === keyB) {\n        return valA < valB ? -1 : 1;\n    }\n    return keyA < keyB ? -1 : 1;\n})\n    .map(([key, val]) => `${escapeUri(key)}=${escapeUri(val)}`)\n    .join('&');\nconst escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);\nconst hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAACA,uBAAuB,GAAIC,YAAY,IAAKC,KAAK,CAACC,IAAI,CAACF,YAAY,EAC3EG,IAAI,CAAC,CAAAC,IAAA,EAAAC,KAAA,KAAgC;EAAA,IAA/B,CAACC,IAAI,EAAEC,IAAI,CAAC,GAAAH,IAAA;EAAA,IAAE,CAACI,IAAI,EAAEC,IAAI,CAAC,GAAAJ,KAAA;EACjC,IAAIC,IAAI,KAAKE,IAAI,EAAE;IACf,OAAOD,IAAI,GAAGE,IAAI,GAAG,EAAE,GAAG,CAAC;EAC/B;EACA,OAAOH,IAAI,GAAGE,IAAI,GAAG,EAAE,GAAG,CAAC;AAC/B,CAAC,EACIE,GAAG,CAACC,KAAA;EAAA,IAAC,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAAF,KAAA;EAAA,UAAAG,MAAA,CAAQC,SAAS,CAACH,GAAG,CAAC,OAAAE,MAAA,CAAIC,SAAS,CAACF,GAAG,CAAC;AAAA,CAAE,EACzDG,IAAI,CAAC,GAAG;AACb,MAAMD,SAAS,GAAIE,GAAG,IAAKC,kBAAkB,CAACD,GAAG,CAAC,CAACE,OAAO,CAAC,UAAU,EAAEC,SAAS,CAAC;AACjF,MAAMA,SAAS,GAAIC,CAAC,QAAAP,MAAA,CAASO,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,EAAE,CAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}